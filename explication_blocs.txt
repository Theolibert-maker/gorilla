Mémo technique détaillé sur la structure de `app.py`
===================================================

Ce document accompagne le projet Gorilla comme une note de mémoire. Il explique méthodiquement chaque bloc du fichier
`app.py`, leurs interactions et les raisons des choix techniques. La lecture suit l'ordre du fichier pour faciliter la
navigation en soutenance.

0. Vue d'ensemble
-----------------
L'application est un jeu 2D écrit avec `pygame` et `pygame_gui`. Elle combine trois couches :

* **Entités graphiques/physiques** — gorilles, projectiles (bananes), explosions et skyline destructible.
* **Orchestrateur** — la classe `GorillaGame` qui gère les rounds, l'IHM, les entrées et la physique.
* **Point d'entrée** — `main()` initialisant pygame, l'UI et lançant la boucle principale.

1. Importations, constantes et ressources partagées
---------------------------------------------------
Le fichier commence par les imports standards (`json`, `math`, `random`, `dataclasses`, `datetime`, `pathlib`, `typing`)
ainsi que `pygame` et `pygame_gui`. Ils se répartissent en trois familles :

1. **Simulation mathématique** — `math` (sin/cos, radians), `random` (vent, skyline), `pygame.Vector2` (positions flottantes).
2. **Persistance** — `json`, `datetime`, `Path` pour sérialiser les scores (`scores.json`) avec horodatage ISO 8601.
3. **Ergonomie du code** — `dataclass` pour déclarer `Gorilla` et `typing` pour annoter `Optional[Projectile]`, etc.

Viennent ensuite des constantes globales : taille de fenêtre, gravité (`GRAVITY`), coefficient de frottement (`DRAG_COEFF`),
vent max (`WIND_MAX`), rayon d'explosion (`EXPLOSION_RADIUS`), nombre de rounds gagnants (`WIN_ROUNDS`), palette de couleurs,
chemin du fichier de scores, police, etc. Centraliser ces valeurs garantit :

* une physique cohérente (tous les projectiles lisent la même gravité) ;
* une expérimentation rapide (modifier un seul nombre change tout le gameplay) ;
* la réutilisation par plusieurs classes sans dépendances circulaires.

Enfin, quelques surfaces (ciel) et polices sont créées une fois pour toutes afin d'éviter des reallocations coûteuses.

2. Classe `Gorilla`
-------------------
`Gorilla` est une dataclass qui joue le rôle de conteneur d'état pour chaque personnage :

* **Attributs** — `rect` (position/tailles sur l'écran), `color` (dominante visuelle), `direction` (1 vers la droite, -1 vers la
gauche). Ces trois éléments suffisent pour dessiner et calculer le point de lancer.
* **`draw(surface)`** — Assemble un sprite stylisé de singe : corps elliptique, ventre clair, tête, yeux, bras, jambes et queue.
Toutes les coordonnées sont dérivées du `rect`, ce qui garantit la cohérence visuelle lorsque le gorille est repositionné sur
un immeuble.
* **`throw_position()`** — Retourne un `pygame.Vector2` situé à l'extrémité du bras lançant. Le décalage horizontal dépend de
`direction` pour que le bras sorte du bon côté, tandis que le décalage vertical garde la banane au niveau de l'épaule.

3. Classe `Projectile`
----------------------
Le projectile encapsule à la fois la simulation physique de la banane et son rendu autonome (traînée + sprite tournant).

* **Initialisation** — Reçoit `start_pos`, `angle_deg`, `speed`, `wind`. L'angle est converti en radians, puis la vitesse est
projetée en composantes : `vel.x = cos(angle) * speed`, `vel.y = -sin(angle) * speed` (axe Y orienté vers le bas dans pygame).
Le vent est stocké pour calculer la vitesse relative air/projectile. L'objet crée aussi une liste `trail_points` pour
mémoriser les positions précédentes et gère un angle de rotation `rotation` (avec une vitesse aléatoire `rotation_speed`).
* **`update(dt)`** — Implémente l'intégration d'Euler :
  1. accélération verticale constante `GRAVITY` ;
  2. accélération horizontale issue des frottements de l'air `a_x = DRAG_COEFF * (wind - vel.x)` ;
  3. mise à jour de `vel` puis `pos` via `vel * dt` ;
  4. enregistrement de la position dans `trail_points` (liste bornée à ~120 éléments) ;
  5. incrément de `rotation` selon `rotation_speed` pour donner l'illusion d'une banane qui vrille.
* **`draw(surface)`** — Deux phases :
  1. **Traînée** — Chaque point ancien est dessiné avec `pygame.draw.circle`. L'intensité de la couleur décroît selon l'indice et
     est clampée afin d'éviter l'erreur `ValueError` observée lors des premiers tests.
  2. **Sprite de banane** — `_get_banana_surface()` construit une surface `52×24 px` seulement la première fois : ellipse
     principale, deux cercles aux extrémités pour courber les bouts, un ovale clair interne et une légère ombre arciforme.
     L'ensemble rappelle le tout premier prototype demandé par l'utilisateur. Cette surface est ensuite tournée via
     `pygame.transform.rotozoom(..., 1.0)` (pas de réduction d'échelle), puis `blit`ée centrée sur `self.pos`.

4. Classe `Explosion`
---------------------
Cette classe matérialise un effet d'explosion court mais expressif à chaque impact.

* **Construction** — À la création, une dizaine de particules sont générées avec position (`Vector2`), vitesse initiale
aléatoire, rayon de départ et couleur chaude. L'effet possède une durée fixe (~0,7 s) stockée dans `self.duration`.
* **`update(dt)`** — Déplace les particules (`pos += vel * dt`), amortit leurs vitesses (`vel *= 0.9`), dilate le rayon (`radius += grow * dt`) et incrémente `self.time` pour savoir quand supprimer l'explosion.
* **`draw(surface)`** — Commence par peindre un halo (surface temporaire en `SRCALPHA` avec deux disques concentriques dont
l'opacité décroît), puis dessine chaque particule comme un petit disque semi-transparent pondéré par `fade = 1 - time/duration`.
Résultat : un flash central lumineux avec quelques étincelles dispersées.

5. Classe `Skyline`
-------------------
`Skyline` gère les immeubles destructibles et fait office de collision map.

* **Attributs** — `surface` (calque hors écran), `buildings` (liste de `pygame.Rect` représentant les immeubles),
`gorilla_spots` (coordonnées des toits aptes à accueillir un gorille).
* **`generate()`** —
  1. crée une surface transparente de taille écran ;
  2. dessine des immeubles de largeurs/hauteurs aléatoires, chacun avec une variation subtile de couleur et des fenêtres stylisées ;
  3. remplit `gorilla_spots` avec des rectangles suffisamment larges sur lesquels on peut poser les personnages.
* **`draw(surface)`** — `blit` direct de la surface préparée, ce qui rend la skyline en O(1) malgré la complexité visuelle.
* **`carve_explosion(center, radius)`** — Dessine un cercle transparent (mode effacement) dans la surface pour simuler un
impact qui creuse les immeubles.
* **`collides(point)`** — Lit la couleur du pixel `surface.get_at((x, y))`. Si l'alpha > 0, on considère qu'un bâtiment solide
est touché. Cette méthode évite d'avoir à gérer des boîtes de collision complexes.

6. Orchestrateur `GorillaGame`
------------------------------
`GorillaGame` est le cœur applicatif. Il maintient l'état du match, orchestre la boucle de jeu, la simulation et l'interface.

### 6.1 Initialisation
Le constructeur reçoit `screen` et `ui_manager`. Il procède comme suit :

1. `_build_sky()` — Prérend un dégradé vertical bleu/orange sur une surface. Cela évite de recalculer le gradient à chaque frame.
2. `_build_ui()` — Crée les panneaux `pygame_gui` :
   * `names_panel` avec deux `UITextEntryLine` pour saisir les pseudos (stockés dans `self.name_inputs`).
   * `throw_panel` contenant deux champs numériques (angle/vitesse), des labels, un bouton « Lancer » et un indicateur du vent.
   * `status_panel` avec un `UITextBox` pour afficher instructions et messages de fin de round.
   * `status_label` en haut de l'écran servant de HUD rapide.
3. Instancie `Skyline`, deux `Gorilla` (gauche/droite), les compteurs de victoires (`self.scores = {0: 0, 1: 0}`), les variables
de tour (`current_player`, `projectile`, `wind`) et la liste `self.explosions`.
4. Appelle `start_match()` afin que la première partie commence immédiatement.

### 6.2 Gestion des rounds
* **`start_match()`** — Réinitialise les scores, efface le texte d'état, remet `current_player` à 0 et enchaîne sur
  `start_round()`.
* **`start_round()`** — Génère une nouvelle ville (`skyline.generate()`), place les gorilles sur deux toits éloignés via
  `_place_gorillas()`, tire un vent aléatoire `[-WIND_MAX, WIND_MAX]`, alterne le premier joueur (simple flip binaire) et efface
  l'ancien projectile. Un message d'état décrit le vent et le joueur actif.

### 6.3 Boucle principale et entrées
* **`run()`** — Boucle `while self.running`. Traitement des événements :
  * `QUIT` → `self.running = False` ;
  * `KEYDOWN` sur `K_r` → `start_match()` (reboot instantané, tel que demandé par l'utilisateur) ;
  * `UI_BUTTON_PRESSED` sur le bouton « Lancer » → `handle_fire()` ;
  * tous les événements sont transmis au `ui_manager`.
  Ensuite, `dt = clock.tick(60) / 1000.0`, suivi de `update(dt)`, `draw()` et `ui_manager.draw_ui(self.screen)`.
* **`handle_fire()`** — Lit l'angle et la vitesse dans les champs texte, tente une conversion float, valide (0 < angle < 180 et
vitesse > 0). En cas d'erreur, `update_status()` affiche un message. Sinon, la méthode construit un `Projectile` à partir de la
position donnée par `current_gorilla.throw_position()` et l'associe au vent courant.

### 6.4 Simulation et collisions
* **`update(dt)`** —
  1. Met à jour les explosions existantes (suppression lorsqu'elles expirent).
  2. Si `self.projectile` est actif, appelle `projectile.update(dt)` puis teste :
     * sorties d'écran (gauche/droite/bas) → `switch_turn("La banane est sortie...")` ;
     * collision skyline (`skyline.collides`) → `skyline.carve_explosion`, `spawn_explosion`, `switch_turn` ;
     * collision gorille adverse (`gorilla.rect.collidepoint`) → `spawn_explosion`, `resolve_hit()`.
* **`spawn_explosion(pos)`** — Ajoute une instance d'`Explosion` centrée sur `pos`.
* **`_place_gorillas()`** — Sélectionne deux toits distants pour placer les `rect` des gorilles (hauteur ajustée pour que les pieds
reposent sur le toit).

### 6.5 Gestion des tours et des scores
* **`switch_turn(message)`** — Passe de 0 à 1 (ou inversement) via `self.current_player = 1 - self.current_player`, remet
`self.projectile = None`, publie le message et informe le panneau de statut. Empêche le spam tant qu'un projectile existe.
* **`resolve_hit(winner_idx, loser_idx)`** — Incrémente `self.scores[winner_idx]`, affiche un texte avec les pseudos (ou
"Joueur 1/2" si vide). Si le gagnant atteint `WIN_ROUNDS`, sauvegarde le match (`save_score`) puis relance `start_match()`.
Sinon, relance simplement `start_round()`.
* **`save_score(winner_idx, loser_idx)`** — Construit un dictionnaire : timestamp ISO, noms des joueurs, vainqueur, perdant,
score final. Lit `scores.json` si présent (liste d'entrées), ajoute l'élément et réécrit le fichier. Ce mécanisme persiste
l'historique des parties pour consultation ultérieure.

### 6.6 Rendu haut niveau
* **`_draw_hud()`** — Affiche en haut d'écran : pseudos, score des rounds, information de vent (flèche orientée selon le signe et
valeur numérique), rappel « R : redémarrer ». Utilise la police partagée pour garder la cohérence graphique.
* **`draw()`** — Ordonne le rendu : ciel → skyline → explosions (halo derrière) → gorilles → projectile (traînée + banane) → HUD →
UI `pygame_gui`. Le respect de cette pile assure que les éléments critiques restent visibles et cliquables.

7. Fonction `main()` et point d'entrée
-------------------------------------
`main()` encapsule l'initialisation système :

1. `pygame.init()` puis création de la fenêtre `SCREEN_SIZE` ;
2. instanciation du `UIManager` associé ;
3. création de `GorillaGame(screen, manager)` ;
4. appel à `game.run()` pour démarrer la boucle ;
5. `pygame.quit()` à la fin pour libérer proprement les ressources SDL.

Le bloc `if __name__ == "__main__": main()` permet d'exécuter directement le jeu ou d'importer `app.py` sans lancer la
boucle (utile pour tests unitaires ou analyses).

Conclusion
----------
Le fichier `app.py` se décompose donc en briques clairement identifiées : entités (gorilles, bananes, explosions, skyline),
contrôleur (`GorillaGame`) et couche système (`main`). Ce mémo détaille chaque méthode, ses entrées, ses effets et ses
interactions, fournissant une base solide pour défendre le projet lors d'une soutenance ou d'un rapport de mémoire.