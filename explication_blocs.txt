Mémo technique détaillé sur la structure de `app.py`
===================================================

Cette annexe a été pensée comme un chapitre de mémoire décrivant en profondeur l'architecture du jeu Gorilla. Elle suit le
fichier `app.py` de haut en bas afin d'expliquer non seulement le rôle de chaque bloc mais aussi les motivations
architecturales, les dépendances et les flux de données. Pour les lecteurs qui défendront ce code, l'objectif est de pouvoir
retracer chaque décision et d'argumenter la cohérence d'ensemble.

1. Importations, constantes et ressources partagées
---------------------------------------------------
Les premières lignes réunissent les modules standards (`json`, `math`, `random`, `dataclasses`, `datetime`, `pathlib`, `typing`)
et les bibliothèques tierces `pygame` / `pygame_gui`. Ce découpage révèle déjà trois préoccupations majeures :

1. **Simulation et mathématiques** — `math` fournit les conversions trigonométriques (degrés → radians), tandis que
   `random` assure la génération procédurale de la skyline et du vent. L'utilisation de `pygame.Vector2` (exposé via
   `pygame`) permet de raisonner en coordonnées flottantes sans perdre de précision lors de l'intégration.
2. **Persistance et traçabilité** — `json`, `datetime` et `Path` coordonnent l'écriture de `scores.json`. La date est formatée
   en ISO 8601 pour simplifier l'archivage et la lecture par des outils externes.
3. **Annotations et ergonomie** — `dataclasses.dataclass` diminue le bruit syntaxique pour `Gorilla`, tandis que `typing`
   clarifie les signatures (par exemple `Optional[Projectile]`) et sert de documentation vivante.

Un bloc de constantes suit immédiatement ces imports. Il fixe les grandeurs physiques (`GRAVITY`, `DRAG_COEFF`, `WIND_MAX`), les
paramètres de gameplay (`EXPLOSION_RADIUS`, `WIN_ROUNDS`) et l'habillage (`SCREEN_SIZE`, palettes de couleurs, police). Centraliser
ces valeurs répond à deux exigences :

* garantir la cohérence des calculs physiques (tous les projectiles lisent la même gravité) ;
* faciliter l'expérimentation pédagogique (on peut illustrer l'effet d'un vent plus fort en modifiant un seul nombre).

Enfin, des surfaces et `pygame.font.Font` sont préparées pour être partagés par plusieurs objets, évitant les réinitialisations
coûteuses à chaque frame.

2. Classe `Gorilla`
-------------------
`Gorilla` est déclarée comme dataclass pour mettre en avant son rôle de conteneur d'état :

* **Attributs** — `rect` (position et taille sur l'écran), `color` (couleur principale), `direction` (1 vers la droite, -1 vers la
  gauche). Ce trio suffit pour dessiner un gorille stylisé et déterminer où débute son lancer.
* **`draw(surface)`** — Composé de primitives `pygame.draw`. Les sous-parties (corps rectangulaire, tête circulaire,
  yeux, bras orienté) s'appuient toutes sur les coordonnées de `rect`. Cette hiérarchie relative garantit qu'un déplacement de
  `rect` se répercute sur l'ensemble du personnage sans recalcul manuel.
* **`throw_position()`** — Retourne un `pygame.Vector2` positionné à l'extrémité du bras (offset horizontal dépendant de
  `direction`, offset vertical constant pour aligner la banane à hauteur d'épaule). En procédant ainsi, la physique ignore la
  morphologie du gorille : la classe se contente de fournir un point d'origine réaliste.

3. Classe `Projectile`
----------------------
Le projectile encapsule la dynamique des bananes explosives. Sa responsabilité est double : intégrer la physique et exposer un
rendu autonome (traînée + sprite de banane courbée).

* **Initialisation** — Le constructeur reçoit `start_pos`, `angle_deg`, `speed` et `wind`. L'angle est converti en radians,
  puis projeté en composantes `vel.x = cos(angle) * speed` et `vel.y = -sin(angle) * speed` (signe négatif car l'axe Y
  croît vers le bas en pixel). Le paramètre `wind` est stocké afin de simuler la vitesse relative air/projectile.
* **`update(dt)`** — Implémente une intégration d'Euler explicite :
  1. calcul de l'accélération verticale (`GRAVITY`),
  2. calcul de l'accélération horizontale issue des frottements : `a_x = DRAG_COEFF * (wind - vel.x)` (plus la banane va vite
     par rapport à l'air, plus elle est freinée dans la direction opposée),
  3. mise à jour de `vel` puis de `pos` via `vel * dt`.
  La méthode enregistre ensuite `pos.copy()` dans `trail_points`. Une fenêtre glissante limite la traînée à ~120 points pour
  préserver la mémoire et le temps de dessin.
* **`draw(surface)`** — Commence par reconstituer la traînée à l'aide de disques de plus en plus sombres (l'intensité verte est
  réduite proportionnellement à l'indice du point et ensuite clampée pour éviter l'erreur `ValueError`). Le cœur du rendu repose
  désormais sur un sprite de banane pré-rendu :
  * `_get_banana_surface()` fabrique une surface transparente 130×90 px inspirée d'un fruit illustré : épaisseur importante, arc
    prononcé, extrémité verte et pointe brune.
  * La silhouette utilise toujours un arc central (spine) mais le pas angulaire plus serré (3°) et un calcul de `thickness`
    dépendant à la fois de la courbure et d'un `taper` donnent un « ventre » généreux côté tige et une pointe affinée.
  * La tige verte est dessinée via une ellipse dédiée, la tête brune par un disque partiellement décalé ; des taches (freckles)
    ponctuent ensuite la peau pour rappeler la référence fournie.
  * Trois bandes superposées (highlight crème, ombre douce et liseré brun) suivent la courbure afin de simuler la lumière sur
    les faces interne/externe tout en conservant un contour net.
  À chaque frame, la surface est récupérée, tournée (`pygame.transform.rotozoom`) selon `self.rotation` pour donner
  l'impression qu'elle vrille en plein vol, puis `blit`ée au centre du projectile.

4. Classe `Explosion`
---------------------
Pour renforcer l'impact visuel des collisions, la classe `Explosion` agit comme un mini système de particules :

* **Initialisation** — Chaque impact génère une dizaine d'étincelles dotées d'une position (`pygame.Vector2`), d'une vitesse,
  d'un rayon initial, d'un facteur de croissance et d'une couleur chaude légèrement aléatoire. Une durée (`0,7 s`) borne l'effet.
* **`update(dt)`** — Avance les particules (`pos += vel * dt`), amortit leur vélocité (`vel *= 0.9`) et dilate progressivement
  le rayon (`radius += grow * dt`). Le compteur `self.time` sert à déterminer quand l'explosion doit cesser d'être affichée.
* **`draw(surface)`** — Construit d'abord un halo sur une surface temporaire `SRCALPHA` (deux cercles concentriques jaunâtres
  dont l'opacité décroît), puis projette chaque étincelle avec une transparence proportionnelle à `fade = 1 - time/duration`.
  Cette combinaison halo + particules donne un flash court mais expressif.

5. Classe `Skyline`
-------------------
`Skyline` gère l'environnement destructible et la logique de collision fine.

* **Attributs internes** — `surface` (le calque off-screen contenant la ville), `buildings` (liste des `pygame.Rect` des immeubles)
  et `gorilla_spots` (points utilisables pour placer les gorilles). Centraliser ces données évite de recalculer la géométrie.
* **`generate()`** —
  1. crée une nouvelle surface transparente de la taille de l'écran ;
  2. remplit la ville d'immeubles aux largeurs aléatoires, en variant légèrement la teinte bleue et la hauteur ;
  3. enregistre la position de toits suffisamment larges pour accueillir un gorille. Ces spots alimentent `_place_gorillas()`.
  Cette génération procédurale renouvelle le gameplay à chaque round.
* **`draw(surface)`** — `blit` direct de la surface vers l'écran principal. Le coût est constant, quelle que soit la complexité
  de la skyline générée.
* **`carve_explosion(center, radius)`** — Dessine un disque transparent dans la surface, ce qui "creuse" les immeubles. Le
  rayon provient de la constante `EXPLOSION_RADIUS` pour harmoniser dégâts visuels et gameplay.
* **`collides(point)`** — Lit le pixel correspondant via `surface.get_at`. Si son alpha est supérieur à zéro, cela signifie que
  la banane touche un bâtiment non détruit. Cette technique d'échantillonnage pixel-precise évite de gérer un maillage complexe.

6. Orchestrateur `GorillaGame`
------------------------------
`GorillaGame` regroupe tout ce qui n'appartient pas explicitement aux entités précédentes : état des rounds, interface graphique,
logique d'entrée utilisateur et rendu final. Pour clarifier, on peut diviser ses responsabilités en cinq sous-chapitres.

### 6.1 Construction et dépendances
Le constructeur reçoit `screen` (surface principale) et `ui_manager`. Il enchaîne plusieurs étapes :

1. `_build_sky()` — Prépare un arrière-plan dégradé bleu/orange pré-rendu (Surface). Ce choix améliore les performances en
   évitant de recalculer le gradient chaque frame.
2. `_build_ui()` — Installe les panneaux `pygame_gui` :
   * `names_panel` (deux `UITextEntryLine`) stockés dans `self.name_inputs` ;
   * `throw_panel` qui mélange `UILabel`, `UITextEntryLine` pour l'angle/la vitesse et un `UIButton` "Lancer" ;
   * `status_panel` muni d'un `UITextBox` défilant pour afficher instructions et résultats ;
   * `status_label` au sommet de l'écran (HUD). Cette redondance assure qu'une information critique est visible même si le
     panneau est masqué derrière la fenêtre de jeu.
3. Instanciation de `Skyline`, `Gorilla` (un à gauche, un à droite), compteurs de victoires (`scores` dictionnaire) et variables
   de tour (`current_player`, `projectile`, `wind`).
4. Appel immédiat à `start_match()` afin de générer le premier round sans interaction supplémentaire.

### 6.2 Cycle de vie des rounds
`start_match()` remet les scores à zéro, réinitialise les messages de statut et appelle `start_round()`. Cette dernière effectue :

* `skyline.generate()` pour renouveler la ville ;
* `_place_gorillas()` qui choisit deux spots distants (un proche de la gauche, l'autre de la droite) en garantissant une marge de
  sécurité minimale ;
* tirage aléatoire d'une valeur de vent dans `[-WIND_MAX, WIND_MAX]` ;
* sélection du joueur qui commence (alternance simple) ;
* effacement de `projectile` pour éviter qu'une banane précédente continue de voler.

Les gorilles sont stockés dans `self.gorillas = [gorilla_left, gorilla_right]`. La variable `current_player` contient l'indice
(0 ou 1), ce qui simplifie l'accès à la structure en permanence.

### 6.3 Gestion des entrées et boucle principale
* **`run()`** — Contient la boucle `while self.running`. Elle traite les événements `pygame`: 
  * `QUIT` ferme proprement,
  * `KEYDOWN` sur `K_r` déclenche `start_match()` pour respecter la consigne « appuyer sur R pour redémarrer »,
  * événements `UI_BUTTON_PRESSED` sur le bouton "Lancer" déclenchent `handle_fire()`.
  Après la gestion des événements, la méthode calcule `dt = clock.tick(60) / 1000.0`, appelle `update(dt)`, puis `draw()`. Enfin,
  `ui_manager.update(dt)` maintient les animations de l'interface.
* **`handle_fire()`** — Lit les champs texte, tente de convertir en float et valide : angle ∈ (0, 180), vitesse > 0. Si les
  conditions sont satisfaites, la méthode calcule `origin = gorilla.throw_position()` puis crée `Projectile`. En cas de valeur
  invalide, elle informe l'utilisateur par `update_status()` sans crasher la boucle.

### 6.4 Simulation et détection de collisions
`update(dt)` s'active uniquement lorsqu'un projectile existe. Son pipeline est :

1. `self.projectile.update(dt)` pour avancer la banane.
2. Vérification des bornes d'écran (`pos.x < 0`, `pos.x > width`, `pos.y > height`). En dehors des limites, la banane est
   détruite et `switch_turn("La banane est sortie de l'écran…")` est appelé.
3. Collision avec la skyline : si `skyline.collides(projectile.pos)` retourne vrai, alors
   * `skyline.carve_explosion(projectile.pos, EXPLOSION_RADIUS)` pour visuel + modification physique ;
   * `spawn_explosion(projectile.pos)` pour ajouter l'effet lumineux correspondant ;
   * `switch_turn("Impact sur un immeuble…")`.
4. Collision avec les gorilles : pour chaque gorille adverse, on teste l'intersection entre le point et `gorilla.rect`. En cas de
   succès, `spawn_explosion(projectile.pos)` puis `resolve_hit(winner, loser)` gèrent la suite.

Cette séquence montre comment la classe centralise toute la logique d'interaction sans disperser les collisions dans plusieurs
fichiers.

### 6.5 Gestion des tours et scoring
* **`switch_turn(message)`** — Change `current_player` en `1 - current_player`, remet `projectile = None` et publie `message` via
  `update_status`. La condition préliminaire `if self.projectile is None` évite qu'un joueur spamme le bouton pendant qu'une
  banane est déjà en vol.
* **`resolve_hit(winner, loser)`** — Incrémente `scores[winner]`, affiche le résultat, puis :
  * si `scores[winner] >= WIN_ROUNDS`, appelle `save_score()` puis `start_match()` (nouveau match complet) ;
  * sinon, relance simplement `start_round()`.
  Les paramètres `winner`/`loser` sont des indices (0/1), ce qui permet de réutiliser `player_name(idx)` pour personnaliser les
  messages.
* **`save_score(winner, loser)`** — Assemble un dictionnaire `{ "timestamp": ..., "winner": ..., "loser": ..., "scores": ... }`,
  lit le fichier JSON existant (s'il existe) puis ajoute l'entrée avant de réécrire le tout. Les exceptions d'E/S sont traitées
  implicitement par Python ; dans le cadre du projet pédagogique, on suppose que le dossier est accessible en écriture.

### 6.6 Rendu haute couche
* **`_draw_hud()`** — Affiche sur une bande supérieure : noms/pseudos (ou "Joueur 1/2" si champs vides), score de rounds,
  intensité du vent (flèche orientée à droite si `wind > 0`, gauche sinon) et rappel « R : redémarrer ». Ce HUD est redessiné à
  chaque frame pour rester synchronisé avec les variables.
* **`draw()`** — Compose la scène dans un ordre fixe : ciel → skyline → gorilles → projectile (s'il existe) → HUD → UI.
  Respecter cet ordre garantit que :
  1. la skyline recouvre le ciel ;
  2. les gorilles apparaissent devant les immeubles ;
  3. la traînée de banane reste visible ;
  4. l'interface utilisateur (textboxes/boutons) reste cliquable au-dessus de tout.

7. Fonction `main()` et point d'entrée
-------------------------------------
`main()` est la glue système. Elle se charge de :

1. `pygame.init()` et création de la fenêtre `SCREEN_SIZE` ;
2. instanciation du `UIManager` (obligatoire pour `pygame_gui`) avec le même viewport ;
3. création de `GorillaGame(screen, manager)` ;
4. appel à `game.run()` ;
5. `pygame.quit()` à la sortie pour libérer les ressources SDL.

Le bloc final `if __name__ == "__main__": main()` autorise deux usages :
* Exécution directe (`python app.py`) pour jouer.
* Importation du module dans des tests unitaires ou des scripts d'analyse sans lancer la boucle graphique, ce qui facilite le
  prototypage d'améliorations.

Conclusion
----------
Le fichier `app.py` articule clairement trois niveaux : entités (gorille, projectile, explosion, skyline), orchestrateur (`GorillaGame`) et
boilerplate système (`main`). Chaque méthode a été documentée ici avec ses entrées, ses effets et sa contribution au flux
général. Cette lecture permet de justifier les choix techniques lors d'une soutenance de projet ou d'un mémoire, en insistant sur
l'intégration entre simulation physique, rendu pygame et interface `pygame_gui`.
